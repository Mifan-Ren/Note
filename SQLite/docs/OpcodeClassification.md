
# SQLite Opcode Classification

*SQLite目前的opcode共有167个[^1]，以下分类整理为个人思路，部分可以通过名称理解的未作标注，opcode作用来自官网文档、代码注释及个人理解*

[^1]:截止版本3.27.2，来源官方网站

### 整体分类

| 类型         | **作用**                                                     | 数量 | 举例                    |
| ------------ | :----------------------------------------------------- | :------: | :------------------ |
| 运算相关     | 进行加减乘除等数学运算与大小比较等逻辑运算                   |  21  | Add, And                |
| 函数实现     | 调用函数功能，或者实现SQL的函数如查找和聚合等                |  8   | AggFinal,  AggInverse   |
| 数据存取相关 | 数据存储，读取相关，针对数据的列，包括使用游标的相关函数，对数据进行读写处理等 |  76  | Column, Count, OpenRead |
| 事务管理     | 事务管理相关，事务开始与提交，日志操作等                     |  18  | AutoCommit, Checkpoint  |
| 数据类型相关 | 判断数据类型和数据转换                                       |  3   | Affinity, Cast          |
| 寄存器相关   | 根据寄存器的内容控制寄存器的跳转，值的设置等                 |  39  | Concat, Copy            |
| 其他         | 标记，验证中止等                                             |  2   | Noop, Abortable         |

### 运算与逻辑运算类

* **Add**: p1+p2 --> p3

* **AddImm**: p2是常数，结果为整数

* **And / or**：p1&p2 --> p3; p1 | p2 --> p3

* **Bitand / Bitor / Bitnot**: 按位与或非，存到p2

* **Compare**: 比较reg（P1）..reg（P1 + P3-1）（调用此向量“A”）和reg（P2）..reg（P2 + P3-1）（“B”）中寄存器的两个向量。保存比较结果以供下一个Jump指令使用，为排序比较
  <<<<<<< HEAD

* **Divide / Multiply / Subtract **： P3 = P2 / x - P1
=======

* **Divide / Multiply / Subtract **： P3 = P2 //*- P1

* **ElseNotEq**: 紧跟在Lt或Gt比较运算符之后。如果对相同的两个操作数进行Eq比较的结果将为NULL或false（0），则跳转到P2。如果两个先前操作数的Eq比较结果为真（1），则通过

* **Eq / Ge / Le / Lt / Ne**: 比较寄存器P1和P3中的值。如果reg（P3）== reg（P1），则跳转到地址P2
* **IsTrue**: 此操作码实现IS TRUE，IS FALSE，IS NOT TRUE和IS NOT FALSE运算符,将寄存器P1中的值解释为布尔值。将布尔值(0或1)存储在寄存器P2中。或者，如果寄存器P1中的值为NULL，则P3将存储在寄存器P2中。如果P4 = 1，求倒数
* **OffsetLimit**: 该操作码执行与LIMIT和OFFSET过程相关的常用计算
* **Permutation**：在下一条指令中设置Compare运算符使用的置换。置换存储在P4操作数中    

### 函数实现

* **AggFinal**：终结聚合函数，P1是内存位置，为聚合函数累加器
* **AggInverse**: 聚合的inverse函数
* **AggStep**: 聚合的step函数[^2]
* **AggStep1**：对聚合执行xStep（如果P1 == 0）或xInverse（如果P1！= 0）函数
* **AggValue**：调用xValue（）函数并将结果存储在寄存器P3中
* **CollSeq**：返回归类序列，由内置的min（），max（）和nullif（）函数使用。（不公开使用）
* **Function**：调用用户函数（P4是指向sqlite3_context对象的指针，该对象包含指向要运行的函数的指针），其中P5参数取自寄存器P2和后继函数。该功能的结果存储在寄存器P3中
* **Function0**：调用用户函数（P4是指向定义函数的FuncDef对象的指针），其中P5参数取自寄存器P2和后继函数，它和Function的功能与聚合函数有关

[^2]: 它和上一个这两个函数功能有待补充

### 事务管理

* **AutoCommit**：将数据库自动提交标志设置为P1（1或0）。如果P2为true，则回滚任何当前活动的btree事务。如果有任何活动的VM（除此之外），则ROLLBACK失败。如果存在使用共享缓存的活动写入VM或活动VM，则COMMIT将失败。该指令导致VM停止
* **Checkpoint**：检查点数据库P1。如果P1当前不处于WAL模式，则这是无操作。参数P2是SQLITE_CHECKPOINT_PASSIVE，FULL，RESTART或TRUNCATE之一。如果检查点分别返回SQLITE_BUSY，则将1或0写入mem [P3]。将检查点后WAL中的页数写入mem [P3 + 1]，并将检查点完成后检查点的WAL页数写入mem [P3 + 2]。但是在出错时，mem [P3 + 1]和mem [P3 + 2]被初始化为-1
* **Close**：关闭先前打开为P1的光标。如果P1当前未打开，则此指令为无操作
* **Expire**：导致预编译语句过期。当使用sqlite3_step（）执行过期语句时，它将自动重新映射（如果它最初是使用sqlite3_prepare_v2（）创建的），或者它将因SQLITE_SCHEMA而失败
* **Gosub**：立即退出，所有打开的游标等都会自动关闭
* **IncrVacuum**：在P1数据库上执行增量vacuum程序的单个步骤。如果vacuum已完成，请跳至指令P2。否则，转到下一条指令
* **IntegrityCk**：对当前打开的数据库进行分析。在寄存器P1中存储描述任何问题的错误消息的文本。如果没有发现问题，请在寄存器P1中存储NULL，用于实现integrity_check编译指示
* **JournalMode**：将数据库P1的日志模式更改为P3。P3必须是PAGER_JOURNALMODE_XXX值之一。如果在各种回滚模式（删除，截断，保持，关闭和内存）之间切换，这是一个简单的操作。不需要IO
* **Program**：执行作为P4传递的触发器程序（类型P4_SUBPROGRAM）
* **ReadCookie**：从数据库P1读取cookie编号P3并将其写入寄存器P2。P3 == 1是架构版本。P3 == 2是数据库格式。P3 == 3是推荐的寻呼机缓存大小，依此类推。P1 == 0是主数据库文件，P1 == 1是用于存储临时表的数据库文件
* **ResetCount**：更改计数器的值将复制到数据库句柄更改计数器（由后续调用sqlite3_changes（）返回）。然后VMs内部更改计数器重置为0.这由触发器程序使用
* **Savepoint**：打开，释放或回滚由参数P4命名的保存点，具体取决于P1的值。要打开新的保存点，P1 == 0。要释放（提交）现有保存点，P1 == 1，或回滚现有保存点P1 == 2
* **SetCookie**：将整数值P3写入数据库P1的cookie编号P2
* **SqlExec**：运行P4字符串中指定的SQL语句
* **SqlExec**：运行P4字符串中指定的SQL语句
* **TableLock**:    获取特定表的锁定。仅在启用共享缓存make功能时使用此指令
* **Trace**: 如果启用了语句跟踪，则在语句跟踪输出上写入P4
* **Transaction**：如果事务尚未激活，则在数据库P1上开始事务。如果P2非零，则启动写入事务，或者如果读取事务已处于活动状态，则将其升级为写入事务。如果P2为零，则启动读取事务
* **Vacuum**：对数据库进行vacuum操作

### 数据存储和读取
* **Column**：与makerecord 配合，从记录中提取p2列
* **ColumnsUsed**：此操作码（仅在SQLite使用SQLITE_ENABLE_COLUMN_USED_MASK编译时才存在）标识使用了光标P1的表或索引的哪些列
* **Count**：将条目数（整数值）存储在由寄存器P2中的光标P1打开的表或索引中
* **Clear**：删除数据库表或索引的所有内容，其数据库文件中的根页由P1给出。但不删除表或索引。
* **CreateBtree**： 如果P1 == 0，则在主数据库文件中分配新的b-tree;如果P1 == 1，则在TEMP数据库文件中分配新的b-tree;如果P1> 1，则在附加的数据库中分配新的b-tree。对于rowid表，P3参数必须为1（BTREE_INTKEY），对于索引或WITHOUT ROWID表，它必须为2（BTREE_BLOBKEY）。新b树的根页号存储在寄存器P2中
* **CursorHint**：返回满足P4中Expr的行。P4表达式中的TK_REGISTER项是指当前保存在寄存器中的值。P4表达式中的TK_COLUMN项指的是光标P1指向的b树中的列。
* **DeferredSeek**：P1是一个开放索引游标，P3是相应表上的游标。此操作码将P3表游标的延迟搜索执行到与当前P1行对应的行，延期查找提高IO效率；P1是打开的索引游标，P3是对应表上的游标。该操作码将P3表指针延迟搜索到对应于P1当前行的行。这是一个延迟搜索。在使用游标读取记录之前，实际上什么都不会发生。这样，如果没有发生读取，就不会发生不必要的I/O。P4可以是一个整数数组(类型为P4_INTARRAY)，其中包含P3表中每一列的一个条目。如果数组条目a(i)非零，那么从游标P3读取列a(i)-1等同于执行延迟查找，然后从P1读取列i。该信息存储在P3中，用于将针对P3的读取重定向到P1，从而可能避免了寻找和读取游标P3的需要。
* **Delete**：删除P1光标当前指向的记录。
* **Destroy**：删除整个数据库表或索引，其数据库文件中的根页由P1给出。
* **DropIndex**：与destroy配合使用，保持数据一致性，删除描述数据库P1中名为P4的索引的内部（内存中）数据结构
* **DropTable**：删除描述数据库P1中名为P4的表的内部（内存中）数据结构
* **DropTrigger**
* **FkCounter**：通过P2增加“约束计数器”（P2可以是负数或正数）
* **FkIfZero**：此操作码测试外键约束计数器当前是否为零。如果是这样，跳转到指令P2。否则，请转到下一条指令
* **Found**: 此操作码测试外键约束计数器当前是否为零。如果是这样，跳转到指令P2。否则，请转到下一条指令
* **NotFound**：此操作使光标处于无法向任一方向前进的状态。换句话说， 在此操作之后，Next和Prev操作码不起作用，*是一个对游标进行操作的控制符，在代码中87156行开始，notfound和Noconflict和found执行相同的语句*
* **NotExists**：P1是在SQL表btree上打开游标的索引（带有整数键）。P3是整数rowid。如果P1不包含带有rowid P3的记录，则立即跳转到P2。或者，如果P2为0，则引发SQLITE_CORRUPT错误。如果P1确实包含带有rowid P3的记录，则将光标指向该记录并进入下一条指令
* **NoConflict**：光标P1在索引btree上。如果P3和P4标识的记录包含任何NULL值，则立即跳转到P2。如果记录的所有术语都不是-NULL，则进行检查以确定P1索引btree中的任何行是否具有匹配的键前缀。如果没有匹配项，请立即跳转到P2。如果匹配，则通过并将P1光标指向匹配的行。
* **IfNoHope**：寄存器P3是形成解压缩记录的P4寄存器中的第一个。光标P1在索引btree上。如果在P1上设置了seekHit标志，则该操作码是无操作，*与notfound等一组，游标跳转语句*
* **IdxDelete**：从寄存器P2开始的P3寄存器的内容形成解压缩的索引键。此操作码从光标P1打开的索引中删除该条目
* **IdxGE / IdxGT / IdxLE / IdxLT**：以P3开头的P4寄存器值形成一个省略PRIMARY KEY的解压缩索引键。 将此键值与P1当前指向的索引进行比较，忽略末尾的PRIMARY KEY或ROWID字段
* **IdxInsert**：寄存器P2包含使用MakeRecord指令创建的SQL索引键 。该操作码将该key写入索引P1该指令仅适用于索引。表的等效指令是Insert
* **IdxRowid**：将寄存器P2写入整数，该整数是光标P1指向的索引键末尾的记录中的最后一个条目。此整数应该是此索引条目指向的表条目的rowid
* **IfNullRow**：检查光标P1以查看它当前是否指向NULL行
* **IfSmaller**：估计表P1中的行数。 如果估计值小于约2 **（0.1 * P3），则跳至 P2[^3 ]
* **Insert**：在光标P1表中写入一个条目。如果新条目尚不存在或者现有条目的数据被覆盖，则创建新条目
* **Last**：下一次使用P1 的Rowid或Column或Prev指令将引用数据库表或索引中的最后一个条目。此操作码使光标配置为从末尾向开始以相反的顺序移动
* **LoadAnalysis**：读取数据库P1的sqlite_stat1表，并将该表的内容加载到内部索引哈希表中。这将导致在准备所有后续查询时使用分析
* **MakeRecord**：将以P1开头的P2寄存器转换为record format[^4 ] ， 用作数据库表中的数据记录或索引中的键。该列码后可以解码记录
* **MaxPgcnt**：尝试将数据库P1的最大页数设置为P3中的值。不要让最大页数低于当前页数，如果P3 == 0，则不要更改最大页数。在寄存器P2中更改后存储最大页数。
* **NewRowid**：获取用作表的键的新整数记录号（也称为“rowid”）。记录号以前未用作光标P1指向的数据库表中的键。新记录号写入寄存器P2
* **Next / Prev**：使光标P1前进，使其指向其表或索引中的下一个键/数据对。如果没有更多的键/值对，则转到下面的指令。但是如果光标前进成功，立即跳转到P2。
* **NullRow**：将光标P1移动到空行

* **Offset**：将寄存器r [P3]中的字节偏移存储到数据库文件中，该文件是光标P1当前指向的记录的有效负载的起始位置

* **OpenAutoindex**：此操作码与OpenEphemeral的工作方式相同。它有一个不同的名称来区分它的用途。使用此操作码创建的表将用于连接中自动创建的瞬态索引

* **OpenDup**：打开一个新光标P1，它指向与光标P2相同的临时表

* **OpenEphemeral**：将新光标P1打开到临时表。即使主数据库是只读的，游标也始终以读/写方式打开。光标关闭时，将自动删除临时表[^5 ] 

* **OpenPseudo**：打开一个指向包含单行数据的假表的新游标。该行的内容是存储器寄存器P2的内容。换句话说，光标P1成为寄存器P2中包含的MEM_Blob内容的别名

* **OpenRead**：在数据库文件中打开其根页为P2的数据库表的只读游标。数据库文件由P3确定。

* **OpenWrite**：在根页为P2的表或索引上打开一个名为P1的读/写游标

* **Pagecount**：将数据库P1中的当前页数写入存储器单元P2

* **ParseSchema**：读取并解析数据库P1的SQLITE_MASTER表中与WHERE子句P4匹配的所有条目

* **ReopenIdx**：首先检查是否在P1上的光标已在同一B树开放的，如果是这样变成码无操作。换句话说，如果光标已经打开，请不要重新打开

* **ResetSorter**：删除光标P1上打开的临时表或sorter中的所有内容

* **ResultRow**：寄存器P1至P1 + P2-1包含单行结果

* **Rewind**：下一次对P1 的Rowid或Column或Next指令的使用将引用数据库表或索引中的第一个条目。如果表或索引为空，则立即跳转到P2。如果表或索引不为空，请转到以下指令。该[^6 ]操作码使光标配置为从开始到结束以正向顺序移动

* **RowData**：将寄存器P2写入光标P1当前指向的行的完整行内容

* **RowID**：在寄存器P2中存储一个整数，它是P1当前指向的表条目的键

* **SeekEnd**：将光标P1定位在btree的末尾，以便将新条目附加到btree上

* **SeekGE / SeekGT / SeekLE / SeekLT**：如果游标P1引用一个SQL表(使用整数键的B-Tree)，则使用寄存器P3中的值作为键。如果游标P1引用一个SQL索引，那么P3就是用作非压缩索引键的P4寄存器数组中的第一个。重新定位游标P1，使其指向大于或等于键值的最小条目。如果没有大于或等于键的记录，且P2不为零，则跳转到P2。**如果使用OPFLAG_SEEKEQ标志打开游标P1，那么这个操作码将始终停留在一个与键值相等的记录上**，或者立即跳转到P2。当光标为OPFLAG_SEEKEQ时，这个操作码后面必须跟着一个具有相同参数的IdxLE操作码。如果这个操作码成功，IdxLE操作码将被跳过，但是IdxLE操作码将在随后的循环迭代中使用。此操作码将光标配置为按从开始到结束的顺序向前移动。换句话说，光标被配置为使用Next，而不是Prev

* **SeekRowid**：P1是在SQL表btree上打开游标的索引（带有整数键）。如果寄存器P3不包含整数，或者如果P1不包含带有rowid P3的记录，则立即跳转到P2。或者，如果P2为0，则引发SQLITE_CORRUPT错误。如果P1确实包含带有rowid P3的记录，则将光标指向该记录并进入下一条指令

* **Sequence**：找到光标P1的下一个可用序列号。将序列号写入寄存器P2

* **Sort**：此操作码与Rewind完全相同，只是它增加了用于测试的未记录的全局变量

* **SorterCompare**：P1是一个sorter光标。该指令将寄存器P3中记录blob的前缀与分拣器光标当前指向的条目的前缀进行比较。仅比较r [P3]的第一个P4字段和分类器记录

* **SorterData**    将分类器光标P1的当前sorter数据写入寄存器P2。然后清除光标P3上的列标题缓存

* **SorterInsert**  寄存器P2包含使用MakeRecord指令创建的SQL索引键

* **Sorternext / Sorteropen**：与上面的类似

* **Sortersort**: 与sort相同

* **VBegin**[^7 ]： P4可以是指向sqlite3_vtab结构的指针。如果是这样，请为该表调用xBegin方法

* **VColumn**：在寄存器P3中存储光标P1的虚拟表的当前行的第P2列的

* **VCreate**：     P2是一个寄存器，用于保存数据库P1中虚拟表的名称

* **VDestroy**：   P4是数据库P1中的虚拟表的名称。调用该表的xDestroy方法

* **Vfilter**：P1是使用VOpen打开的游标。P2是过滤结果集为空时跳转到的地址

* **VNext**： 将虚拟表P1前进到其结果集中的下一行并跳转到指令P2

* **VOpen / VUpdate / VRename**：P4是指向虚拟表对象的指针，即sqlite3_vtab结构

[^3 ]:涉及Btree读取

[^4 ]:[https://www.sqlite.org/fileformat2.html#record_format] 有效负载的格式，表格式中定义

[^5 ]:用于临时表打开，Btree涉及位掩码，不需要对外存读写

[^6 ]:配合next
[^7 ]:Virtual table，是一种自定义的扩展，允许用户通过代码定制表的数据结构和数据内容表中的数据的来源；对于普通表，来源于数据库的行列值；而对于虚表，来源于用户自定义的函数，可以使数据库中的数据，也可以使其他的外部数据，如：磁盘文件(csv, excel)(https://www.sqlite.org/vtab.html)



### 数据类型相关

* **Affinity**：列亲和性的确定
* **Blob**：P4指向一个P1字节长的blob数据。将此blob存储在寄存器P2中
* **Cast**： 强制类型转换
### 寄存器相关

* **Concat**：将寄存器P1中的文本添加到寄存器P2中文本的末尾，并将结果存储在寄存器P3中。如果P1或P2文本为NULL，则在P3中存储NULL。P3 = P2 || P1

* **Copy**: 将寄存器P1..P1 + P3复制到寄存器P2..P2 + P3中。该指令生成值的深层副本

* **DecrJumpZero**：寄存器P1必须包含整数。如果新值正好为零，则递减P1中的值并跳转到P2。

* **EndCoroutine**：寄存器P1中的地址处的指令是Yield。 跳转到该Yield的P2参数。跳转后，寄存器P1变为未定义

* **InitCoroutine**：设置寄存器P1使之屈服到位于地址P3的协同程序。如果P2！= 0，则协程实现紧跟在此操作码之后。因此跳过协程实现来解决P2问题

* **Yield**：使用寄存器P1中的值交换程序计数器。这具有屈服于协程的效果。如果此指令启动的协程以Yield或Return结束， 则继续执行下一条指令。但是如果该指令启动的协程以**EndCoroutine**结束 ，则跳转到P2而不是继续下一条指令

* **HaltIfNull**：检查寄存器P3中的值。如果是NULL，则暂停使用参数P1，P2和P4仿佛这是一个暂停指令

* **If**：如果寄存器P1中的值为真，则跳转到P2。如果该值为数字且非零，则该值被视为true

* **IfNot**：如果寄存器P1中的值为False，则跳转到P2。如果数值为零，则该值被视为false

* **IfNotZero**

* **IfPos**：寄存器P1必须包含整数。如果寄存器P1的值为1或更大，则从P1中的值减去P3并跳转到P2

* **Init**：程序包含此操作码的单个实例作为第一个操作码

* **Int64**：P4是指向64位整数值的指针。将该值写入寄存器P2

* **IntCopy**：将寄存器P1中保存的整数值传送到寄存器P2

* **Int**：32位整数值P1被写入寄存器P2

* **IsNull**：如果寄存器P1中的值为NULL，则跳转到P2

* **Jump**：跳转到地址P1，P2或P3的指令，具体取决于最近的比较指令中P1矢量是否小于等于或大于P2矢量

* **MemMax**：P1是该VM的根帧中的寄存器（如果在子程序中执行该指令，则根帧与当前帧不同）。将寄存器P1的值设置为其当前值的最大值和寄存器P2中的值。

* **Move**：将寄存器P1..P1 + P3-1中的P3值移到寄存器P2..P2 + P3-1中。寄存器P1..P1 + P3-1保持为NULL。寄存器范围P1..P1 + P3-1和P2..P2 + P3-1重叠是错误的。P3小于1是错误的

* **MustBeInt**：强制寄存器P1中的值为整数

* **Null**：将NULL写入寄存器P2

* **Once**：在每次调用字节码程序时第一次遇到此操作码时，直到下一条指令。 在同一次调用期间，在第二次和所有后续遇到时跳转到P2。

* **Param**：该操作码仅存在于通过程序指令调用的子程序中 。将当前存储在调用（父）帧的存储器单元中的值复制到当前帧地址空间中的单元P2。触发器程序使用它来访问新的值和旧的值

* **Real**: P4是指向64位浮点值的指针。将该值写入寄存器P2

* **RealAffinity**: 如果寄存器P1保持整数，则将其转换为实数值

* **Remainder**: 在整数寄存器P2除以寄存器P1之后计算余数并将结果存储在寄存器P3中

* **Return**：跳转到寄存器P1中的地址之后的下一条指令。跳转后，寄存器P1变为未定义。

* **RowSetAdd**：将寄存器P2保存的整数值插入寄存器P1中保存的RowSet对象

* **RowSetRead**：从P1中的RowSet对象中提取最小值，并将该值放入寄存器P3中

* **RowSetTest**：假设寄存器P3保持64位整数值。如果寄存器P1包含RowSet对象并且该**RowSet**对象包含P3中保存的值，则跳转到寄存器P2。否则，将P3中的整数插入RowSet并继续执行下一个操作码

* **SCopy**：将寄存器P1的浅拷贝复制到寄存器P2中

* **SeekHit**：将光标P1上的seekHit标志设置为P2中的值

* **SequenceTest**      ：P1是一个sorter光标。如果序列计数器当前为零，则跳转到P2。无论是否进行跳转，都要递增序列值

* **ShiftLeft / Shiftright** 将寄存器P2中的整数值向左/右移动寄存器P1中整数指定的位数
* **SoftNull**：将寄存器P1设置为MakeRecord指令看到的值NULL，但是不释放与寄存器相关的任何字符串或blob内存，这样，如果该值是之前使用检查复制的字符串或blob，那么复制将继续有效

* **String**：长度为P1（字节）的字符串值P4存储在寄存器P2中

* **String8**：P4指向一个空终止的UTF-8字符串。在第一次执行此操作码之前，此操作码将转换为String操作码

* **Variable**：将绑定参数P1的值传送到寄存器P2
### 其他
* **Abortable**：验证是否可以发生中止。断言如果此时中止可能导致数据库损坏。此操作码仅出现在调试版本中。如果没有写入，或者存在活动语句日志，则中止是安全的
* **Noop**：终止符
